# -*- coding: utf-8 -*-
"""211000/Maimoona.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DQOIpDh_0sAaIvE4tFBAIP5EE5v9N0MC
"""

#  Maimoona Saeed / BSCS-8C / 211000
#  Data Science  Assignment 01

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Load dataset
df = pd.read_csv("/loangrant - loangrant.csv")

# Display dataset information
print("Dataset Overview:")
print(df.info())
print("\nFirst Few Rows:")
print(df.head())

# Check for missing values
print("\nMissing Values per Column:")
print(df.isnull().sum())

# Missing Values Handling
# Justification: Missing values can create bias in analysis.
# We replace numerical missing values with median since it is robust to outliers.
for col in df.select_dtypes(include=[np.number]).columns:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].median(), inplace=True)

# Exploratory Data Analysis (EDA)
# Histograms to understand the distribution of numerical columns
plt.figure(figsize=(12, 8))
df.hist(figsize=(12, 10), bins=20)
plt.tight_layout()
plt.show()

# Boxplots to detect outliers
# Justification: Boxplots visually show extreme values which might affect model performance
numeric_cols = df.select_dtypes(include=[np.number]).columns
df[numeric_cols].plot(kind='box', subplots=True, layout=(len(numeric_cols)//2, 2), figsize=(12, 8))
plt.tight_layout()
plt.show()

# Scatter plot example (if relevant columns exist)
if 'ApplicantIncome' in df.columns and 'LoanAmount' in df.columns:
    sns.scatterplot(data=df, x='ApplicantIncome', y='LoanAmount')
    plt.title("Applicant Income vs Loan Amount")
    plt.show()

# Outlier Detection & Handling using IQR Method
# Justification: Outliers can distort statistical analysis, so we replace them with the median
Q1 = df[numeric_cols].quantile(0.25)
Q3 = df[numeric_cols].quantile(0.75)
IQR = Q3 - Q1
outlier_condition = (df[numeric_cols] < (Q1 - 1.5 * IQR)) | (df[numeric_cols] > (Q3 + 1.5 * IQR))

# Count and percentage of outliers
outlier_percentage = (outlier_condition.sum() / len(df)) * 100
print("\nPercentage of Outliers per Column:")
print(outlier_percentage)

# Replace outliers with median to maintain distribution integrity
for column in numeric_cols:
    median_value = df[column].median()
    df.loc[outlier_condition[column], column] = median_value

# Compute correlation matrix for numerical attributes
corr_matrix = df[numeric_cols].corr()
print(df.columns)  # exact column name

# Print correlation matrix
print("Correlation Matrix:\n", corr_matrix)

#attributes with correlation >= 0.6 or <= -0.6
high_corr = []
for c1 in numeric_cols:
    for c2 in numeric_cols:
        if c1 != c2:
            if abs(corr_matrix.loc[c1, c2]) >= 0.6:
                high_corr.append((c1, c2, corr_matrix.loc[c1, c2]))
print("High Correlation Attributes:")
# Remove duplicates
unique_high_corr = list(set(tuple(sorted(pair[:2])) + (pair[2],) for pair in high_corr))
print("Highly correlated attributes (|corr| >= 0.6):")
for item in unique_high_corr:
    print(item)

# Standardizing 'Years in Current Job'
# Justification: Converting categorical text values into numeric for easier analysis
print(df["Years in current job"].unique())

def categorize_years_in_current_job(x):
    if pd.isnull(x):
        return "n/a"

    # Convert to string and make lowercase for consistency
    x_str = str(x).lower().strip()

    # Handle "10+ years"
    if "10+" in x_str:
        return "above 10 years"

    #  "< 1 year"
    if "< 1" in x_str:
        return "< 1 year"

    # Remove the words "years" or "year"
    x_str = x_str.replace("years", "").replace("year", "").strip()

    # Now try to parse the numeric part (e.g., "2", "3", "9")
    try:
        years = float(x_str)
    except ValueError:
        # If parsing fails for any reason, return "n/a"
        return "n/a"

    #  apply your numeric boundaries
    if years < 1:
        return "< 1 year"
    elif 2 <= years <= 4:
        return "two - four years"
    elif 5 <= years <= 7:
        return "five - seven years"
    elif 8 <= years <= 9:
        return "eight - nine years"
    else:
        return "above 10 years"


df.columns
if 'Years in current job' in df.columns:
    df['Years in current job'] = df['Years in current job'].apply(categorize_years_in_current_job)
    print(df['Years in current job'])
    print("Replaced 'Years_in_current_job' values with the new categories.")

# Save cleaned dataset to the current directory
df.to_csv("cleaned_loangrant.csv", index=False)
print("\nPreprocessing completed and saved as cleaned_loangrant.csv in the current directory")

# Load and display cleaned dataset

print("\nCleaned Dataset Overview:")
print(cleaned_df.info())
print("\nFirst Few Rows of Cleaned Dataset:")
print(cleaned_df.head())Z